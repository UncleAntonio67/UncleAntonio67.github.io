<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="作者： Martin Kleppmann阅读日期：20250811——20250830学习网站：http:&#x2F;&#x2F;ddia.vonng.com&#x2F; 目录第一部分：数据系统基础——设计数据密集型应用所赖的基本思想  数据系统架构中的权衡  定义非功能性需求  数据模型与查询语言  存储与检索  编码与演化第二部分：分布式数据——存储在一台机器上的数据转向讨论分布在多台机器上的数据 复制  分片  事务">
<meta property="og:type" content="article">
<meta property="og:title" content="设计数据密集型应用">
<meta property="og:url" content="http://example.com/2025/08/16/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="作者： Martin Kleppmann阅读日期：20250811——20250830学习网站：http:&#x2F;&#x2F;ddia.vonng.com&#x2F; 目录第一部分：数据系统基础——设计数据密集型应用所赖的基本思想  数据系统架构中的权衡  定义非功能性需求  数据模型与查询语言  存储与检索  编码与演化第二部分：分布式数据——存储在一台机器上的数据转向讨论分布在多台机器上的数据 复制  分片  事务">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-08-16T15:25:50.000Z">
<meta property="article:modified_time" content="2025-08-16T15:25:50.771Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/08/16/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>设计数据密集型应用 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/16/%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计数据密集型应用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-08-16 23:25:50" itemprop="dateCreated datePublished" datetime="2025-08-16T23:25:50+08:00">2025-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>作者： Martin Kleppmann<br>阅读日期：20250811——20250830<br>学习网站：<a target="_blank" rel="noopener" href="http://ddia.vonng.com/">http://ddia.vonng.com/</a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>第一部分：数据系统基础——设计数据密集型应用所赖的基本思想</p>
<ol>
<li>数据系统架构中的权衡 </li>
<li>定义非功能性需求 </li>
<li>数据模型与查询语言 </li>
<li>存储与检索 </li>
<li>编码与演化<br>第二部分：分布式数据——存储在一台机器上的数据转向讨论分布在多台机器上的数据</li>
<li>复制 </li>
<li>分片 </li>
<li>事务 </li>
<li>分布式系统的麻烦 </li>
<li>一致性与共识<br>第三部分：派生数据——从其他数据集派生出一些数据集的系统。</li>
<li>批处理 </li>
<li>流处理 </li>
<li>数据系统的未来</li>
</ol>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p><strong>数据密集型应用（data-intensive applications）</strong> 正在通过使用这些技术进步来推动可能性的边界。一个应用被称为 <strong>数据密集型</strong> 的，如果 <strong>数据是其主要挑战</strong>（数据量，数据复杂度或数据变化速度）—— 与之相对的是 <strong>计算密集型</strong>，即处理器速度是其瓶颈。</p>
<h1 id="第一部分：数据系统基础"><a href="#第一部分：数据系统基础" class="headerlink" title="第一部分：数据系统基础"></a>第一部分：数据系统基础</h1><h2 id="1、数据系统架构中的权衡"><a href="#1、数据系统架构中的权衡" class="headerlink" title="1、数据系统架构中的权衡"></a>1、数据系统架构中的权衡</h2><p>如果数据管理是开发应用程序的主要挑战之一，我们就称应用程序为 <strong>数据密集型（data-intensive）</strong> 的，关心诸如<strong>存储和处理大量数据、管理数据变更、在面对故障和并发时确保一致性，以及确保服务高可用</strong>等问题。一般需要通过<strong>数据库、缓存、索引、流批处理</strong>来构建。</p>
<h3 id="分析型与事务型系统"><a href="#分析型与事务型系统" class="headerlink" title="分析型与事务型系统"></a>分析型与事务型系统</h3><p>三类人：</p>
<ul>
<li><strong>后端工程师</strong>：构建处理读取和更新数据请求的服务；这些服务通常直接或间接地通过其他服务为外部用户提供服务</li>
<li><strong>业务分析师</strong>：生成关于组织活动的报告，以帮助管理层做出更好的决策</li>
<li><strong>数据科学家</strong>：在数据中寻找新的见解，或创建由数据分析和机器学习&#x2F;AI 支持的面向用户的产品功能<br>业务分析师和数据科学家两者都执行 <strong>分析</strong>，这意味着他们查看用户和后端服务生成的数据，但他们通常不修改这些数据，这导致了两种类型系统之间的分离：</li>
<li><strong>事务型系统</strong> 由后端服务和数据基础设施组成，在这里创建数据，例如通过服务外部用户。在这里，应用程序代码基于用户执行的操作读取和修改其数据库中的数据。</li>
<li><strong>分析型系统</strong> 服务于业务分析师和数据科学家的需求。它们包含来自事务型系统的只读数据副本，并针对分析所需的数据处理类型进行了优化。<br>随着这些系统的成熟，出现了两个新的专业角色：<strong>数据工程师</strong> 和 <strong>分析工程师</strong>。</li>
<li><strong>数据工程师</strong>是知道如何集成事务型系统和分析型系统的人，并更广泛地负责组织的数据基础设施</li>
<li><strong>分析工程师</strong>对数据进行建模和转换，使其对组织中的业务分析师和数据科学家更有用</li>
</ul>
<h4 id="事务处理与分析的特征"><a href="#事务处理与分析的特征" class="headerlink" title="事务处理与分析的特征"></a>事务处理与分析的特征</h4><ul>
<li><strong>OLTP</strong>：事务型系统通常通过某个键查找少量记录（这称为 <strong>点查询</strong>）。基于用户的输入插入、更新或删除记录。因为这些应用程序是交互式的，这种访问模式被称为 <strong>联机事务处理</strong>（OLTP）</li>
<li><strong>OLAP</strong>：分析具有非常不同的访问模式。通常，分析查询会扫描大量记录，并计算聚合统计信息（如计数、求和或平均值），而不是将单个记录返回给用户，被称为 <strong>联机分析处理</strong>（OLAP）<table>
<thead>
<tr>
<th>属性</th>
<th>事务型系统（OLTP）</th>
<th>分析型系统（OLAP）</th>
</tr>
</thead>
<tbody><tr>
<td>主要读取模式</td>
<td>点查询（通过键获取单个记录）</td>
<td>对大量记录进行聚合</td>
</tr>
<tr>
<td>主要写入模式</td>
<td>创建、更新和删除单个记录</td>
<td>批量导入（ETL）或事件流</td>
</tr>
<tr>
<td>人类用户示例</td>
<td>Web&#x2F;移动应用程序的最终用户</td>
<td>内部分析师，用于决策支持</td>
</tr>
<tr>
<td>机器使用示例</td>
<td>检查操作是否被授权</td>
<td>检测欺诈&#x2F;滥用模式</td>
</tr>
<tr>
<td>查询类型</td>
<td>固定的查询集，由应用程序预定义</td>
<td>分析师可以进行任意查询</td>
</tr>
<tr>
<td>数据代表</td>
<td>数据的最新状态（当前时间点）</td>
<td>随时间发生的事件历史</td>
</tr>
<tr>
<td>数据集大小</td>
<td>GB 到 TB</td>
<td>TB 到 PB</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h4><p>90 年代初，公司倾向于停止使用其 OLTP 系统进行分析目的，而是在单独的数据库系统上运行分析。这个单独的数据库被称为 <strong>数据仓库</strong>。有以下几个原因：</p>
<ul>
<li>数据孤岛问题</li>
<li>查询模式和数据布局不太合适</li>
<li>分析查询相当昂贵<br>数据仓库包含公司中所有各种 OLTP 系统中数据的只读副本。数据从 OLTP 数据库中提取（使用定期数据转储或连续更新流），转换为分析友好的模式，清理，然后加载到数据仓库中。这种将数据导入数据仓库的过程称为 <strong>提取-转换-加载</strong>（ETL）<br>[[file-20250811204322471.png]]<br>一些数据库系统提供 <strong>混合事务&#x2F;分析处理</strong>（HTAP），旨在在单个系统中启用 OLTP 和分析，而无需从一个系统 ETL 到另一个系统。<strong>HTAP 不会取代数据仓库</strong>。相反，它在同一应用程序需要既执行扫描大量行的分析查询，又以低延迟读取和更新单个记录的场景中很有用。</li>
</ul>
<h5 id="从数据仓库到数据湖"><a href="#从数据仓库到数据湖" class="headerlink" title="从数据仓库到数据湖"></a>从数据仓库到数据湖</h5><p><strong>数据分析师</strong>：使用通过 SQL 查询的 <strong>关系</strong> 数据模型<br><strong>数据科学家</strong>：将数据转换为适合训练机器学习模型的形式（特征工程）；使用自然语言处理技术尝试从中提取结构化信息。<br>数据科学家不喜欢在数据仓库等关系数据库中工作，更喜欢使用 Python 数据分析库（如 pandas 和 scikit-learn）、统计分析语言（如 R）和分布式分析框架。<br>组织面临着以适合数据科学家使用的形式提供数据的需求。通过数据湖解决：<br><strong>数据湖</strong>：一个集中的数据存储库，保存任何可能对分析有用的数据副本，通过 ETL 过程从事务型系统获得。与数据仓库的区别在于，数据湖只是包含文件，而不强制任何特定的文件格式或数据模型。数据湖中的文件可能是数据库记录的集合，使用 Avro 或 Parquet 等文件格式编码，但它们同样可以包含文本、图像、视频、传感器读数、稀疏矩阵、特征向量、基因组序列或任何其他类型的数据 <a target="_blank" rel="noopener" href="http://ddia.vonng.com/ch1/#fn:15">15</a>。除了更灵活之外，这通常也比关系数据存储更便宜，因为数据湖可以使用商品化的文件存储，如对象存储<br>ETL 过程已经泛化为 <strong>数据管道</strong><br>从数据湖加载数据到单独的数据仓库之外，还可以直接在数据湖中的文件上运行典型的数据仓库工作负载（SQL 查询和业务分析），以及数据科学&#x2F;机器学习工作负载。这种架构被称为 <strong>数据湖仓</strong>，它需要一个查询执行引擎和一个元数据（例如，模式管理）层来扩展数据湖的文件存储。<br><strong>数据湖仓</strong>：数据湖上的仓，是湖也是仓</p>
<h5 id="超越数据湖"><a href="#超越数据湖" class="headerlink" title="超越数据湖"></a>超越数据湖</h5><p>在某些情况下，分析系统的输出被提供给事务型系统（这个过程有时被称为 <strong>反向 ETL</strong>）<br>例如，在分析系统中训练的机器学习模型可能会部署到生产环境中，以便为最终用户生成推荐，例如”购买了 X 的人也购买了 Y”。这种分析系统的部署输出也被称为 <strong>数据产品</strong></p>
<h4 id="权威数据源与派生数据"><a href="#权威数据源与派生数据" class="headerlink" title="权威数据源与派生数据"></a>权威数据源与派生数据</h4><p><strong>权威记录系统</strong>：权威记录系统，也称为 权威数据源，保存某些数据的权威或 规范 版本。当新数据进入时，例如作为用户输入，它首先写入这里。每个事实只表示一次。如果另一个系统与权威记录系统之间存在任何差异，那么权威记录系统中的值（根据定义）是正确的。<br><strong>派生数据系统</strong>：派生系统中的数据是从另一个系统获取一些现有数据并以某种方式转换或处理它的结果。如果你丢失了派生数据，你可以从原始源重新创建它。一个经典的例子是缓存：如果存在，可以从缓存提供数据，但如果缓存不包含你需要的内容，你可以回退到底层数据库。反规范化值、索引、物化视图、转换的数据表示和在数据集上训练的模型也属于这一类别。</p>
<ul>
<li>分析系统通常是派生数据系统，因为它们是在其他地方创建的数据的消费者。</li>
<li>事务型服务可能包含权威记录系统和派生数据系统的混合。</li>
</ul>
<h3 id="云服务与自托管"><a href="#云服务与自托管" class="headerlink" title="云服务与自托管"></a>云服务与自托管</h3><p>公认的管理智慧是，作为组织核心竞争力或竞争优势的事物应该在内部完成，而非核心、例行或常见的事物应该留给供应商。<br> <strong>自托管</strong> 的现成软件（开源或商业），即自己部署</p>
<h4 id="云服务的利弊"><a href="#云服务的利弊" class="headerlink" title="云服务的利弊"></a>云服务的利弊</h4><p>云服务的最大缺点是你无法控制它：</p>
<ul>
<li>功能定制开发</li>
<li>服务宕机等恢复</li>
<li>出错难以诊断</li>
<li>存在数据安全问题</li>
</ul>
<h4 id="云原生系统架构"><a href="#云原生系统架构" class="headerlink" title="云原生系统架构"></a>云原生系统架构</h4><p>从头开始设计为云原生的系统已被证明具有几个优势：在相同硬件上具有更好的性能、从故障中更快恢复、 能够快速扩展计算资源以匹配负载，以及支持更大的数据集</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>自托管系统</th>
<th>云原生系统</th>
</tr>
</thead>
<tbody><tr>
<td>事务型&#x2F;OLTP</td>
<td>MySQL、PostgreSQL、MongoDB</td>
<td>AWS Aurora 、Azure SQL DB Hyperscale 、Google Cloud Spanner</td>
</tr>
<tr>
<td>分析型&#x2F;OLAP</td>
<td>Teradata、ClickHouse、Spark</td>
<td>Snowflake、Google BigQuery、Azure Synapse Analytics</td>
</tr>
</tbody></table>
<h6 id="云服务的分层"><a href="#云服务的分层" class="headerlink" title="云服务的分层"></a>云服务的分层</h6><ul>
<li>自托管软件倾向于使用非常通用的计算资源：CPU、RAM、文件系统和 IP 网络。</li>
<li>云实例可以更快地配置，并且有更多种类的大小，但除此之外，它们与传统计算机类似<br>云原生服务的关键思想是不仅使用由操作系统管理的计算资源，还基于较低级别的云服务构建更高级别的服务。例如：</li>
<li><strong>对象存储</strong> 服务存储大文件，隐藏了底层物理机器，不必担心任何一台机器上的磁盘空间用完，也不会丢失数据。</li>
<li>许多其他服务反过来建立在对象存储和其他云服务之上：例如，Snowflake 是一个基于云的分析数据库（数据仓库），依赖于 S3 进行数据存储</li>
</ul>
<h6 id="存储和计算的分离"><a href="#存储和计算的分离" class="headerlink" title="存储和计算的分离"></a>存储和计算的分离</h6><p><strong>传统计算</strong>：磁盘存储被认为是持久的，为了容忍单个硬盘的故障，通常使用 RAID（独立磁盘冗余阵列）在连接到同一台机器的几个磁盘上维护数据副本。它对访问文件系统的应用程序是透明的。<br><strong>云计算</strong>：云原生系统通常将这些磁盘更多地视为临时缓存，而不是长期存储。如果实例被替换，本地磁盘会不可访问<br>云服务还提供可以从一个实例分离并附加到另一个实例的虚拟磁盘存储，种虚拟磁盘实际上不是物理磁盘，而是由一组单独的机器提供的云服务，它模拟磁盘的行为。但是对网络很敏感。<br>云原生服务通常避免使用虚拟磁盘，而是建立在针对特定工作负载优化的专用存储服务之上。对象存储服务（如 S3）设计用于长期存储相当大的文件，大小从数百千字节到几千兆字节不等。数据库中存储的单个行或值通常比这小得多；<br><strong>云数据库通常在单独的服务中管理较小的值，并将较大的数据块（包含许多单个值）存储在对象存储中</strong><br>云原生系统中，存储（磁盘）和计算（CPU 和 RAM）在某种程度上分离或 <strong>解耦</strong>。</p>
<h4 id="云时代的运维"><a href="#云时代的运维" class="headerlink" title="云时代的运维"></a>云时代的运维</h4><p><strong>运维</strong>：确保服务可靠地交付给用户（包括配置基础设施和部署应用程序），并确保稳定的生产环境（包括监控和诊断可能影响可靠性的任何问题）<br>从单个机器到服务的重点转移伴随着运维角色的变化。提供可靠服务的高级目标保持不变，但流程和工具已经发展。DevOps&#x2F;SRE 理念更加强调：自动化、频繁更新等等。<br>云正在改变运维的角色，但对运维的需求比以往任何时候都大。</p>
<h3 id="分布式与单节点系统"><a href="#分布式与单节点系统" class="headerlink" title="分布式与单节点系统"></a>分布式与单节点系统</h3><p>涉及多台机器通过网络通信的系统称为 <strong>分布式系统</strong>。参与分布式系统的每个进程称为 <strong>节点</strong>。做分布式有很多原因，如：高可用、可伸缩、低延迟、弹性、可持续性等等</p>
<h4 id="分布式系统的问题"><a href="#分布式系统的问题" class="headerlink" title="分布式系统的问题"></a>分布式系统的问题</h4><ul>
<li>网络传输中断、响应时间慢、分布式事务等等</li>
</ul>
<h4 id="微服务与-Serverless"><a href="#微服务与-Serverless" class="headerlink" title="微服务与 Serverless"></a>微服务与 Serverless</h4><p>分布系统的最常见方式是：分为客户端和服务器，并让客户端向服务器发出请求。最常见的是使用 HTTP 进行此通信。<br>这种构建应用程序的方式传统上被称为 <strong>面向服务架构</strong>（SOA），目前被细化为<strong>微服务</strong> 架构。<br>微服务架构的特点：服务有一个明确定义的目的；每个服务公开一个可以由客户端通过网络调用的 API，每个服务有一个负责其维护的团队。<br>带来的复杂性：每个服务都需要用于部署新版本、调整分配的硬件资源以匹配负载、收集日志、监控服务健康状况以及在出现问题时向值班工程师发出警报的基础设施。</p>
<h4 id="云计算与超级计算"><a href="#云计算与超级计算" class="headerlink" title="云计算与超级计算"></a>云计算与超级计算</h4><p>云计算不是构建大规模计算系统的唯一方式；另一种选择是 <strong>高性能计算</strong>（HPC），也称为 <strong>超级计算</strong>。HPC 通常有不同的优先级并使用不同的技术：</p>
<ul>
<li>HPC 通常有不同的优先级并使用不同的技术。</li>
<li>通常运行大型批处理作业，定期将其计算状态检查点到磁盘。</li>
<li>通常通过共享内存和远程直接内存访问（RDMA）进行通信，这支持高带宽和低延迟</li>
</ul>
<h3 id="数据系统、法律与社会"><a href="#数据系统、法律与社会" class="headerlink" title="数据系统、法律与社会"></a>数据系统、法律与社会</h3><p><strong>通用数据保护条例</strong>（GDPR）：多欧洲国家居民对其个人数据更大的控制权和法律权利，类似的隐私法规已在世界各地的各个国家和州采用，包括例如加州消费者隐私法（CCPA）。关于 AI 的法规，例如 <strong>欧盟 AI 法案</strong>，对个人数据的使用方式施加了进一步的限制。</p>
<h2 id="2-定义非功能性需求"><a href="#2-定义非功能性需求" class="headerlink" title="2. 定义非功能性需求"></a>2. 定义非功能性需求</h2><p>应用程序的非功能需求，比如应用程序应该快速、可靠、安全、合规，并且易于维护<br>从一个案例研究开始本章，研究社交网络服务可能如何工作，这将提供性能和可伸缩性的实际案例。</p>
<h3 id="案例研究：社交网络首页时间线"><a href="#案例研究：社交网络首页时间线" class="headerlink" title="案例研究：社交网络首页时间线"></a>案例研究：社交网络首页时间线</h3><p>社交网络服务：假设用户每天发布 5 亿条帖子，或平均每秒 5,700 条帖子。偶尔，速率可能飙升至每秒 150,000 条帖子。<br>[[file-20250812104503252.png]]<br>帖子应该是及时的，所以假设在某人发布帖子后，我们希望他们的粉丝能够在 5 秒内看到它。一种方法是让用户的客户端每 5 秒重复上述查询（这称为 _轮询_）。如果我们假设有 1000 万用户同时在线登录，这意味着每秒运行 200 万次查询。即使增加轮询间隔，这也是很大的负载。</p>
<h4 id="时间线的物化与更新"><a href="#时间线的物化与更新" class="headerlink" title="时间线的物化与更新"></a>时间线的物化与更新</h4><p>每次用户发布帖子时，我们查找他们的所有粉丝，并将该帖子插入到每个粉丝的首页时间线中——就像向邮箱投递消息一样。现在当用户登录时，我们可以简单地给他们这个预先计算的首页时间线。此外，要接收时间线上任何新帖子的通知，用户的客户端只需订阅添加到其首页时间线的帖子流。<br>[[file-20250812104720007.png]]这种预先计算和更新查询结果的过程称为 <strong>物化</strong>，时间线缓存是 <em>物化视图</em> 的一个例子</p>
<h3 id="描述性能"><a href="#描述性能" class="headerlink" title="描述性能"></a>描述性能</h3><p>考虑两种主要的度量类型：</p>
<ul>
<li><strong>响应时间</strong>：从用户发出请求到收到所请求答案的经过时间。</li>
<li><strong>吞吐量</strong>：系统正在处理的每秒请求数，或每秒数据量。<br>随着服务的吞吐量接近其容量，由于排队，响应时间急剧增加。<br>[[file-20250812105314815.png]]<br>就性能指标而言，响应时间通常是用户最关心的，而吞吐量决定了所需的计算资源，因此决定了服务特定工作负载的成本。<br>如果系统的最大吞吐量可以通过添加计算资源显著增加，则称系统为 _可伸缩的_。</li>
</ul>
<h4 id="延迟与响应时间"><a href="#延迟与响应时间" class="headerlink" title="延迟与响应时间"></a>延迟与响应时间</h4><ul>
<li><em>响应时间</em> 是客户端看到的；它包括系统中任何地方产生的所有延迟。</li>
<li><em>服务时间</em> 是服务主动处理用户请求的持续时间。</li>
<li><em>排队延迟</em> 可能发生在流程中的几个点：例如，在收到请求后，它可能需要等待直到 CPU 可用才能被处理；如果同一台机器上的其他任务通过出站网络接口发送大量数据，响应数据包可能需要在发送之前进行缓冲。</li>
<li><em>延迟</em> 是一个涵盖请求未被主动处理时间的总称，即在此期间它是 <em>潜在的_。特别是，_网络延迟</em> 或 <em>网络延迟</em> 指的是请求和响应在网络中传输所花费的时间。<br>[[file-20250812110210600.png]]</li>
</ul>
<h4 id="平均值、中位数与百分位数"><a href="#平均值、中位数与百分位数" class="headerlink" title="平均值、中位数与百分位数"></a>平均值、中位数与百分位数</h4><p>因为响应时间因请求而异，我们需要将其视为值的 _分布_，而不是单个数字。<br><strong>平均响应时间</strong>：对于估计吞吐量限制很有用<br><strong>中位数</strong>：如果你将响应时间列表从最快到最慢排序，那么 <em>中位数</em> 就在中间中位数成为了解用户通常需要等待多长时间的良好指标。中位数也称为 _第 50 百分位_，有时缩写为 <em>p50_。<br><strong>百分位数</strong>：为了弄清异常值有多糟糕，_第 95_、_99</em> 和 <em>99.9</em> 百分位数很常见，它们是 95%、99% 或 99.9% 的请求比该特定阈值快的响应时间阈值。<br>响应时间的高百分位数，也称为 _尾部延迟_，很重要，因为它们直接影响用户的服务体验。</p>
<h4 id="响应时间指标的应用"><a href="#响应时间指标的应用" class="headerlink" title="响应时间指标的应用"></a>响应时间指标的应用</h4><p>高百分位数在被多次调用作为服务单个最终用户请求的一部分的后端服务中尤其重要。<br>百分位数通常用于 _服务级别目标_（SLO）和 _服务级别协议_（SLA），作为定义服务预期性能和可用性的方式</p>
<h3 id="可靠性与容错"><a href="#可靠性与容错" class="headerlink" title="可靠性与容错"></a>可靠性与容错</h3><p>可靠性：即使出现问题也能继续正确工作。<br>为了更准确地说明出现问题，我们将区分 故障 和 失效：</p>
<ul>
<li><strong>故障</strong>：故障是指系统的某个特定 <em>部分</em> 停止正确工作：例如，如果单个硬盘驱动器发生故障，或单台机器崩溃，或外部服务（系统所依赖的）发生中断。</li>
<li><strong>失效</strong>：失效是指 <em>整个</em> 系统停止向用户提供所需的服务；换句话说，当它不满足服务级别目标（SLO）时。<br>故障和失效之间的区别可能会令人困惑，因为它们在不同层面上是同一件事。</li>
</ul>
<h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><p><strong>容错</strong>：如果系统在发生某些故障时仍继续向用户提供所需的服务，我们称系统为 _容错的_。<br><strong>单点故障</strong>：如果系统不能容忍某个部分变得有故障，我们称该部分为 _单点故障_（SPOF），因为该部分的故障会升级导致整个系统的失效。<br><strong>故障注入</strong>：在这种容错系统中，通过故意触发故障来 <em>增加</em> 故障率是有意义。通过故意引发故障，你确保容错机制不断得到锻炼和测试，这可以增加你对故障自然发生时将被正确处理的信心。<br><strong>混沌工程</strong>：一门旨在通过故意注入故障等实验来提高对容错机制的信心的学科。</p>
<h4 id="硬件与软件故障"><a href="#硬件与软件故障" class="headerlink" title="硬件与软件故障"></a>硬件与软件故障</h4><p>常见的硬件故障：</p>
<ul>
<li>大约 2-5% 的磁性硬盘驱动器每年发生故障</li>
<li>大约 0.5-1% 的固态硬盘（SSD）每年发生故障</li>
<li>大约千分之一的机器有一个 CPU 核心偶尔计算错误的结果，可能是由于制造缺陷</li>
<li>RAM 中的数据也可能被损坏，要么是由于宇宙射线等随机事件，要么是由于永久性物理缺陷。即使使用纠错码（ECC）的内存，超过 1% 的机器在给定年份遇到不可纠正的错误<br>在大规模系统中，硬件故障发生得足够频繁，以至于它们成为正常系统运行的一部分。</li>
</ul>
<h5 id="通过冗余容忍硬件故障"><a href="#通过冗余容忍硬件故障" class="headerlink" title="通过冗余容忍硬件故障"></a>通过冗余容忍硬件故障</h5><p>我们对不可靠硬件的第一反应通常是向各个硬件组件添加冗余，以降低系统的故障率。</p>
<ul>
<li>磁盘可以设置为 RAID 配置（将数据分布在同一台机器的多个磁盘上，以便故障磁盘不会导致数据丢失）</li>
<li>服务器可能有双电源和可热插拔的 CPU<br>硬件冗余增加了单台机器的正常运行时间,使用分布式系统有一些优势，例如能够容忍一个数据中心的完全中断。<br><strong>滚动升级</strong>：如果你需要重新启动机器（例如，应用操作系统安全补丁），单服务器系统需要计划停机时间，而多节点容错系统可以一次修补一个节点，而不影响用户的服务。这称为 <em>滚动升级</em></li>
</ul>
<h5 id="软件故障"><a href="#软件故障" class="headerlink" title="软件故障"></a>软件故障</h5><p>硬件故障大多数都是独立的，软件故障通常是高度相关的。这种故障比不相关的硬件故障更难预料，并且它们往往导致比硬件故障更多的系统失效。</p>
<ul>
<li>在特定情况下导致每个节点同时失效的软件错误。</li>
<li>使用某些共享、有限资源（如 CPU 时间、内存、磁盘空间、网络带宽或线程）的失控进程</li>
<li>系统所依赖的服务变慢、无响应或开始返回损坏的响应。<br>软件故障的设计方案：仔细考虑系统中的假设和交互；彻底测试；进程隔离；允许进程崩溃和重新启动；避免反馈循环，如重试风暴</li>
</ul>
<h4 id="人类与可靠性"><a href="#人类与可靠性" class="headerlink" title="人类与可靠性"></a>人类与可靠性</h4><p>在日常业务的务实现实中，组织通常优先考虑创收活动而不是增加其抵御错误的韧性的措施。如果在更多功能和更多测试之间有选择，许多组织可以理解地选择功能。鉴于这种选择，当可预防的错误不可避免地发生时，责怪犯错误的人是没有意义的——问题是组织的优先事项。<br>管理层应该借此机会从每天与之合作的人的角度了解社会技术系统如何工作的细节，并根据这些反馈采取措施改进它</p>
<h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><p><strong>可伸缩性</strong>：用来描述系统应对负载增加能力的术语</p>
<h4 id="描述负载"><a href="#描述负载" class="headerlink" title="描述负载"></a>描述负载</h4><p>包括：吞吐量的度量、某个变量数量的峰值、还有其他影响访问模式并因此影响可伸缩性要求的负载统计特征<br>目标是在最小化运行系统成本的同时保持系统性能在 SLA 的要求范围内</p>
<h4 id="共享内存、共享磁盘与无共享架构"><a href="#共享内存、共享磁盘与无共享架构" class="headerlink" title="共享内存、共享磁盘与无共享架构"></a>共享内存、共享磁盘与无共享架构</h4><p>增加服务硬件资源的最简单方法是将其移动到更强大的机器。<br><strong>纵向伸缩</strong>：购买一台机器（或租用云实例）具有更多 CPU 核心、更多 RAM 和更多磁盘空间。<br><strong>共享内存架构</strong>：通过使用多个进程或线程在单台机器上获得并行性；成本增长速度快于线性：具有两倍硬件资源的高端机器通常成本远远超过两倍<br><strong>共享磁盘架构</strong>：使用几台具有独立 CPU 和 RAM 的机器，但将数据存储在机器之间共享的磁盘阵列上，这些机器通过快速网络连接：_网络附加存储_（NAS）或 _存储区域网络_（SAN）<br><strong>无共享架构</strong>（ <em>横向伸缩</em> 或 _向外扩展_）：具有多个节点的分布式系统，每个节点都有自己的 CPU、RAM 和磁盘。节点之间的任何协调都在软件级别通过传统网络完成。</p>
<ul>
<li>优点：有线性伸缩的潜力，它可以使用提供最佳性价比的任何硬件</li>
<li>缺点：显式分片，它会产生分布式系统的所有复杂性</li>
</ul>
<h4 id="可伸缩性原则"><a href="#可伸缩性原则" class="headerlink" title="可伸缩性原则"></a>可伸缩性原则</h4><p>可伸缩性的一个良好通用原则是将系统分解为可以在很大程度上相互独立运行的较小组件<br>另一个好原则是不要让事情变得比必要的更复杂。如果单机数据库可以完成工作，它可能比复杂的分布式设置更可取。</p>
<h3 id="可运维性"><a href="#可运维性" class="headerlink" title="可运维性"></a>可运维性</h3><p>软件的大部分成本不在其初始开发中，而在其持续维护中——修复错误、保持其系统运行、调查故障、将其适应新平台、为新用例修改它、偿还技术债务和添加新功能<br>几个广泛适用的原则：</p>
<ul>
<li><strong>可运维性（Operability）</strong>：使组织容易保持系统平稳运行</li>
<li><strong>简单性（Simplicity）</strong>：通过使用易于理解、一致的模式和结构来实施它，并避免不必要的复杂性，使新工程师容易理解系统。</li>
<li><strong>可演化性（Evolvability）</strong>：使工程师将来容易对系统进行更改，随着需求变化而适应和扩展它以用于未预料的用例。</li>
</ul>
<h4 id="可运维性：让运维更轻松"><a href="#可运维性：让运维更轻松" class="headerlink" title="可运维性：让运维更轻松"></a>可运维性：让运维更轻松</h4><p>运维很重要：良好的运维通常可以解决糟糕（或不完整）软件的局限性，但再好的软件碰上糟糕的运维也难以可靠地运行<br>良好的可操作性意味着使常规任务变得容易，使运维团队能够将精力集中在高价值活动上。 数据系统可以做各种事情来使常规任务变得容易，包括：</p>
<ul>
<li>允许监控工具检查系统的关键指标，并支持可观测性工具</li>
<li>避免对单个机器的依赖（允许在系统整体继续不间断运行的同时关闭机器进行维护）</li>
<li>提供良好的文档和易于理解的操作模型</li>
</ul>
<h4 id="简单性：管理复杂度"><a href="#简单性：管理复杂度" class="headerlink" title="简单性：管理复杂度"></a>简单性：管理复杂度</h4><p>推理复杂性的一种尝试是将其分为两类，<strong>本质复杂性</strong> 和 <strong>偶然复杂性</strong>：</p>
<ul>
<li>本质复杂性是应用程序问题域中固有的</li>
<li>偶然复杂性仅由于我们工具的限制而产生<br>管理复杂性的最佳工具之一是 <strong>抽象</strong>。良好的抽象可以在干净、易于理解的外观后面隐藏大量实现细节。良好的抽象也可以用于各种不同的应用程序。</li>
</ul>
<h4 id="可演化性：让变化更容易"><a href="#可演化性：让变化更容易" class="headerlink" title="可演化性：让变化更容易"></a>可演化性：让变化更容易</h4><p>在组织流程方面，<em>敏捷</em> 工作模式为适应变化提供了框架。敏捷社区还开发了在频繁变化的环境中开发软件时有用的技术工具和流程， 例如测试驱动开发（TDD）和重构。</p>
<h2 id="3-数据模型与查询语言"><a href="#3-数据模型与查询语言" class="headerlink" title="3. 数据模型与查询语言"></a>3. 数据模型与查询语言</h2><p><strong>数据模型</strong>不仅影响软件的编写方式，还影响我们 <strong>思考问题</strong> 的方式。<br>如何用更低层次的数据模型来 <strong>表示</strong>应用程序：</p>
<ul>
<li>观察现实世界并用对象或数据结构，以及操作这些数据结构的 API 来建模。这些结构通常是特定于应用程序的。</li>
<li>用通用的数据模型来表达它们，例如 JSON 或 XML 文档、关系数据库中的表，或者图中的顶点和边</li>
<li>用内存、磁盘或网络上的字节来表示文档&#x2F;关系&#x2F;图数据<br><strong>基本思想</strong>：每一层通过提供一个简洁的数据模型来隐藏下层的复杂性。<br>在本章中，通过比较关系模型、文档模型、基于图的数据模型、事件溯源和数据框来探讨这些权衡。</li>
</ul>
<h3 id="关系模型与文档模型"><a href="#关系模型与文档模型" class="headerlink" title="关系模型与文档模型"></a>关系模型与文档模型</h3><p> 1970 年Edgar Codd提出最早的的关系模型：SQL，数据被组织成 <strong>关系</strong>（在 SQL 中称为 <strong>表</strong>），其中每个关系是 <strong>元组</strong>（在 SQL 中称为 <strong>行</strong>）的无序集合。<br> 20 世纪 80 年代中期，关系数据库管理系统（RDBMS）和 SQL 已成为大多数需要存储和查询具有某种规则结构的数据的人的首选工具。<br> 20 世纪 70 年代和 80 年代初，<strong>网状模型</strong> 和 <strong>层次模型</strong> 是主要的替代方案，但关系模型最终战胜了它们。<br>  2010 年代，<strong>NoSQL</strong> 是试图推翻关系数据库主导地位的最新流行词。一些数据库将自己标榜为 _NewSQL_，因为它们旨在提供 NoSQL 系统的可伸缩性以及传统关系数据库的数据模型和事务保证。 NoSQL 和 NewSQL 的想法在数据系统设计中产生了很大的影响，但随着这些原则被广泛采用，这些术语的使用已经减少。<br>  NoSQL 运动的一个持久影响是 <strong>文档模型</strong> 的流行，它通常将数据表示为 JSON。 这个模型最初由专门的文档数据库（如 MongoDB 和 Couchbase）推广，尽管大多数关系数据库现在也增加了 JSON 支持。</p>
<h4 id="对象关系不匹配"><a href="#对象关系不匹配" class="headerlink" title="对象关系不匹配"></a>对象关系不匹配</h4><p>大部分应用程序开发都是使用面向对象的编程语言完成的。如果数据存储在关系表中，则需要在应用程序代码中的对象和数据库的表、行、列模型之间建立一个笨拙的转换层。这种模型之间的脱节有时被称为 <strong>阻抗不匹配</strong>。</p>
<h5 id="对象关系映射（ORM）"><a href="#对象关系映射（ORM）" class="headerlink" title="对象关系映射（ORM）"></a>对象关系映射（ORM）</h5><p>对象关系映射（ORM）框架（如 ActiveRecord 和 Hibernate）减少了这个转换层所需的样板代码量，但它们经常受到批评，有如下问题：</p>
<ul>
<li>ORM 很复杂，无法完全隐藏两种模型之间的差异</li>
<li>ORM 通常仅用于 OLTP 应用程序开发，为分析目的提供数据的数据工程师仍然需要使用底层的关系表示</li>
<li>许多 ORM 仅适用于关系型 OLTP 数据库</li>
<li>一些 ORM 会自动生成关系模式，但这些模式对于直接访问关系数据的用户来说可能很尴尬</li>
<li>ORM 使得意外编写低效查询变得容易，例如 <em>N+1 查询问题</em><br>ORM的优势：</li>
<li>对于非常适合关系模型的数据，ORM 减少了这种转换所需的样板代码量</li>
<li>ORM 有助于缓存数据库查询的结果，这可以帮助减少数据库的负载</li>
<li>ORM 还可以帮助管理模式迁移和其他管理活动</li>
</ul>
<h5 id="用于一对多关系的文档数据模型"><a href="#用于一对多关系的文档数据模型" class="headerlink" title="用于一对多关系的文档数据模型"></a>用于一对多关系的文档数据模型</h5><p><strong>一对多关系</strong>的关系化表达<br>[[file-20250812214919026.png]]<br>JSON 模型能减少应用程序代码和存储层之间的阻抗不匹配，但是JSON 作为数据编码格式也存在问题。JSON 表示具有更好的 _局部性_，所有相关信息都在一个地方，使查询既更快又更简单。<br>[[file-20250812215109300.png]]</p>
<h4 id="规范化、反规范化与连接"><a href="#规范化、反规范化与连接" class="headerlink" title="规范化、反规范化与连接"></a>规范化、反规范化与连接</h4><p>使用 ID，数据更加规范化：对人类有意义的信息只存储在一个地方，所有引用它的地方都使用 ID。当你直接存储文本时，你在使用它的每条记录中都复制了对人类有意义的信息；这种表示是 <em>反规范化</em> 的。<br>规范化表示的缺点是，每次要显示包含 ID 的记录时，都必须进行额外的查找以将 ID 解析为人类可读的内容。<br>文档数据库可以存储规范化和反规范化的数据，但它们通常与反规范化相关联 —— 部分是因为 JSON 数据模型使得存储额外的反规范化字段变得容易，部分是因为许多文档数据库中对连接的弱支持使得规范化不方便。</p>
<h5 id="规范化的权衡"><a href="#规范化的权衡" class="headerlink" title="规范化的权衡"></a>规范化的权衡</h5><p>作为一般原则，规范化数据通常写入更快（因为只有一个副本），但查询更慢（因为它需要连接）；反规范化数据通常读取更快（连接更少），但写入更昂贵（更多副本要更新，使用更多磁盘空间）<br>规范化往往更适合 OLTP 系统，其中读取和更新都需要快速；分析系统通常使用反规范化数据表现更好，因为它们批量执行更新，只读查询的性能是主要关注点<br>在中小规模的系统中，规范化数据模型通常是最好的，因为你不必担心保持数据的多个副本相互一致，执行连接的成本是可以接受的。然而，在非常大规模的系统中，连接的成本可能会成为问题。</p>
<h5 id="社交网络案例研究中的反规范化"><a href="#社交网络案例研究中的反规范化" class="headerlink" title="社交网络案例研究中的反规范化"></a>社交网络案例研究中的反规范化</h5><p>通过 ID 查找人类可读信息的过程称为 <em>hydrating</em> ID，它本质上是在应用程序代码中执行的连接<br>在读取数据时必须执行连接并不像有时声称的那样，是创建高性能、可扩展服务的障碍。<br><strong>规范化和反规范化本质上并不好或坏</strong> —— <strong>它们只是在读写性能以及实施工作量方面的权衡</strong>。</p>
<h4 id="多对一与多对多关系"><a href="#多对一与多对多关系" class="headerlink" title="多对一与多对多关系"></a>多对一与多对多关系</h4><p>[[Pasted image 20250813140710.png]]<br>多对一和多对多关系不容易适应一个自包含的 JSON 文档；它们更适合规范化表示。<br>[[Pasted image 20250813140803.png]]<br>规范化表示仅在一个地方存储关系，并依赖 _二级索引_来允许有效地双向查询关系。</p>
<h4 id="星型与雪花型：分析模式"><a href="#星型与雪花型：分析模式" class="headerlink" title="星型与雪花型：分析模式"></a>星型与雪花型：分析模式</h4><p>数据仓库通常是关系型的，并且数据仓库中表结构有一些广泛使用的约定：<em>星型模式_、_雪花模式_、_维度建模</em> ，以及 _一张大表_（OBT）。<br>一个可能在杂货零售商的数据仓库中找到的星型模式示例。<br>[[Pasted image 20250813141442.png]]<br>一个大型企业可能在其数据仓库中有许多 PB 的交易历史，主要表示为事实表。<br>事实表中的一些列是属性，例如产品售出的价格和从供应商那里购买它的成本（允许计算利润率）。事实表中的其他列是对其他表的外键引用，称为 <strong><em>维度表</em><strong>。由于事实表中的每一行代表一个事件，</strong>维度</strong>代表事件的 <em>谁_、_什么_、_哪里_、_何时_、_如何</em> 和 _为什么_。</p>
<ul>
<li><strong>星形模式</strong>：当表关系被可视化时，事实表位于中间，被其维度表包围；到这些表的连接就像星星的光芒。</li>
<li><strong>雪花模式</strong>：星型模式的变体，维度被进一步分解为子维度。雪花模式比星型模式更规范化，但星型模式通常更受欢迎，因为它们对分析师来说更简单<br>星型或雪花模式主要由多对一关系组成，表示为事实表对维度表的外键，或维度对子维度的外键。<br>原则上，其他类型的关系可能存在，但它们通常被反规范化以简化查询。<br>一些数据仓库模式进一步进行反规范化，完全省略维度表，将维度中的信息折叠到事实表上的反规范化列中，这种方法被称为 **<em>一张大表</em>**（OBT），虽然它需要更多的存储空间，但有时可以实现更快的查询。</li>
</ul>
<h4 id="何时使用哪种模型"><a href="#何时使用哪种模型" class="headerlink" title="何时使用哪种模型"></a>何时使用哪种模型</h4><ul>
<li>文档数据模型的主要论点是模式灵活性、由于局部性而获得更好的性能，以及对于某些应用程序来说，它更接近应用程序使用的对象模型。</li>
<li>关系模型通过为连接、多对一和多对多关系提供更好的支持来反击。<br>应用程序中的数据具有类似文档的结构，可以使用文档模型，将类似文档的结构 _切碎_（shredding）为多个表的关系技术可能导致繁琐的模式和不必要复杂的应用程序代码。<br>一些应用程序允许用户选择项目的顺序,文档模型很好地支持此类应用程序，因为项目（或它们的 ID）可以简单地存储在 JSON 数组中以确定它们的顺序。<br>文档模型有局限性：不能直接引用文档中的嵌套项</li>
</ul>
<h5 id="文档模型中的模式灵活性"><a href="#文档模型中的模式灵活性" class="headerlink" title="文档模型中的模式灵活性"></a>文档模型中的模式灵活性</h5><p><strong>大多数文档数据库以及关系数据库中的 JSON 支持不会对文档中的数据强制执行任何模式。</strong></p>
<ul>
<li>**<em>读时模式</em>**：数据的结构是隐式的，只有在读取数据时才解释，文档数据库</li>
<li>**<em>写时模式</em>**：关系数据库的传统方法，其中模式是显式的，数据库确保所有数据在写入时都符合它<br>读时模式类似于编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查。<br>如果集合中的项目由于某种原因并非都具有相同的结构则读时模式方法是有利的 —— 例如，因为：</li>
<li>有许多不同类型的对象，将每种类型的对象放在自己的表中是不切实际的。</li>
<li>数据的结构由你无法控制且可能随时更改的外部系统决定。</li>
</ul>
<h5 id="读写的数据局部性"><a href="#读写的数据局部性" class="headerlink" title="读写的数据局部性"></a>读写的数据局部性</h5><p>文档通常存储为单个连续字符串，编码为 JSON、XML 或二进制变体（如 MongoDB 的 BSON）。如果你的应用程序经常需要访问整个文档（例如，在网页上渲染它），则这种 <strong><em>存储局部性</em> 具有性能优势。</strong><br>将相关数据存储在一起以获得局部性的想法并不限于文档模型。Google 的 Spanner 数据库在关系数据模型中提供相同的局部性属性，允许模式声明表的行应该交错（嵌套）在父表中；由 Google 的 Bigtable 推广并在 HBase 和 Accumulo 等中使用的 <em>宽列</em> 数据模型具有 <em>列族</em> 的概念，其目的类似于管理局部性。</p>
<h5 id="文档的查询语言"><a href="#文档的查询语言" class="headerlink" title="文档的查询语言"></a>文档的查询语言</h5><p>关系数据库和文档数据库之间的另一个区别是你用来查询它的语言或 API。大多数关系数据库使用 SQL 查询，但文档数据库更加多样化。</p>
<ul>
<li>XML 数据库通常使用 XQuery 和 XPath 查询，它们旨在允许复杂的查询，包括跨多个文档的连接，并将其结果格式化为 XML</li>
<li>JSON Pointer 和 JSONPath 为 JSON 提供了等效于 XPath 的功能。</li>
<li>MongoDB 的聚合管道，其用于连接的 <code>$lookup</code> 运算符，是 JSON 文档集合查询语言的一个例子。</li>
</ul>
<h5 id="文档和关系数据库的融合"><a href="#文档和关系数据库的融合" class="headerlink" title="文档和关系数据库的融合"></a>文档和关系数据库的融合</h5><p>关系数据库增加了对 JSON 类型和查询运算符的支持，以及索引文档内属性的能力。一些文档数据库（如 MongoDB、Couchbase 和 RethinkDB）增加了对连接、二级索引和声明式查询语言的支持。<br>关系-文档混合是一个强大的组合。</p>
<h3 id="图数据模型"><a href="#图数据模型" class="headerlink" title="图数据模型"></a>图数据模型</h3><p>图由两种对象组成：_顶点_（也称为 <em>节点</em> 或 _实体_）和 _边_（也称为 <em>关系</em> 或 _弧_）。许多类型的数据可以建模为图。典型的例子包括：</p>
<ul>
<li><strong>社交图</strong>：顶点是人，边表示哪些人相互认识。</li>
<li><strong>网页图</strong>：顶点是网页，边表示指向其他页面的 HTML 链接。</li>
<li><strong>道路或铁路网络</strong>：顶点是交叉点，边表示它们之间的道路或铁路线。<br>图的表示方式：</li>
<li>**<em>邻接表</em>**：每个顶点存储其相距一条边的邻居顶点的 ID。以使用 _邻接矩阵_，这是一个二维数组，其中每一行和每一列对应一个顶点，当行顶点和列顶点之间没有边时值为零，如果有边则值为一。邻接表适合图遍历，矩阵适合机器学习<br>同质数据图&#x2F;非同质数据图<br>图的构建和查询数据的方式：</li>
<li><em>属性图</em> 模型（由 Neo4j、Memgraph、KùzuDB  和其他 实现）</li>
<li><em>三元组存储</em> 模型（由 Datomic、AllegroGraph、Blazegraph 和其他实现）</li>
<li>图的四种查询语言（Cypher、SPARQL、Datalog 和 GraphQL）</li>
</ul>
<h4 id="属性图"><a href="#属性图" class="headerlink" title="属性图"></a>属性图</h4><p>在 _属性图_（也称为 _标记属性图_）模型中，将图存储视为由两个关系表组成，一个用于顶点，一个用于边。每个顶点包含：</p>
<ul>
<li>唯一标识符</li>
<li>标签（字符串），描述此顶点表示的对象类型</li>
<li>一组出边</li>
<li>一组入边</li>
<li>属性集合（键值对）<br>每条边包含：</li>
<li>唯一标识符</li>
<li>边开始的顶点（_尾顶点_）</li>
<li>边结束的顶点（_头顶点_）</li>
<li>描述两个顶点之间关系类型的标签</li>
<li>属性集合（键值对）<br>此模型的一些重要方面是：</li>
</ul>
<ol>
<li>任何顶点都可以有一条边将其与任何其他顶点连接。</li>
<li>给定任何顶点，你可以有效地找到其入边和出边，从而 <em>遍历</em> 图</li>
<li>通过对不同类型的顶点和关系使用不同的标签，你可以在单个图中存储几种不同类型的信息，同时仍保持简洁的数据模型。</li>
</ol>
<h4 id="Cypher-查询语言"><a href="#Cypher-查询语言" class="headerlink" title="Cypher 查询语言"></a>Cypher 查询语言</h4><p><em>Cypher</em> 是用于属性图的查询语言，最初为 Neo4j 图数据库创建，后来作为 <em>openCypher</em> 发展为开放标准<br>除了 Neo4j，Cypher 还得到 Memgraph、KùzuDB、Amazon Neptune、Apache AGE（在 PostgreSQL 中存储）等的支持。它以电影《黑客帝国》中的角色命名，与密码学中的密码无关</p>
<h4 id="SQL-中的图查询"><a href="#SQL-中的图查询" class="headerlink" title="SQL 中的图查询"></a>SQL 中的图查询</h4><p>在关系数据库中，你通常事先知道查询中需要哪些连接。另一方面，在图查询中，你可能需要遍历可变数量的边才能找到你要查找的顶点 —— 也就是说，连接的数量不是预先固定的。</p>
<ul>
<li>在 Cypher 中，<code>:WITHIN*0..</code> 非常简洁地表达了这个事实：它意味着”跟随 <code>WITHIN</code> 边，零次或多次”。它就像正则表达式中的 <code>*</code> 运算符。</li>
<li>SQL:1999 以来，查询中可变长度遍历路径的想法可以使用称为 _递归公用表表达式_（<code>WITH RECURSIVE</code> 语法）的东西来表达。<br>4 行 Cypher 查询需要 31 行 SQL 的事实表明，正确选择数据模型和查询语言可以产生多大的差异。<br>有计划向 SQL 标准添加一种名为 GQL 的图查询语言，它将提供受 Cypher、GSQL  和 PGQL 启发的语法。</li>
</ul>
<h4 id="三元组存储与-SPARQL"><a href="#三元组存储与-SPARQL" class="headerlink" title="三元组存储与 SPARQL"></a>三元组存储与 SPARQL</h4><p>元组存储模型大多等同于属性图模型<br>在三元组存储中，所有信息都以非常简单的三部分语句的形式存储：（<em>主语_、_谓语_、_宾语_）。例如，在三元组（_Jim_、_likes_、_bananas_）中，_Jim</em> 是主语，<em>likes</em> 是谓语（动词），<em>bananas</em> 是宾语。<br>三元组的主语等同于图中的顶点。宾语是两种东西之一：</p>
<ol>
<li>原始数据类型的值，如字符串或数字。在这种情况下，三元组的谓语和宾语等同于主语顶点上属性的键和值。</li>
<li>图中的另一个顶点。在这种情况下，谓语是图中的边，主语是尾顶点，宾语是头顶点。<br>三元组存储是另一种在其原始用例之外找到用途的语义网技术：即使你对语义网没有兴趣，三元组也可以成为应用程序的良好内部数据模型。</li>
</ol>
<h5 id="RDF-数据模型"><a href="#RDF-数据模型" class="headerlink" title="RDF 数据模型"></a>RDF 数据模型</h5><p>Turtle 语言实际上是在 _资源描述框架_（RDF）<a target="_blank" rel="noopener" href="http://ddia.vonng.com/ch3/#fn:55">55</a> 中编码数据的一种方式，这是为语义网设计的数据模型。RDF 数据也可以用其他方式编码，例如（更冗长地）用 XML</p>
<h5 id="SPARQL-查询语言"><a href="#SPARQL-查询语言" class="headerlink" title="SPARQL 查询语言"></a>SPARQL 查询语言</h5><p><em>SPARQL</em> 是使用 RDF 数据模型的三元组存储的查询语言（它是 <em>SPARQL Protocol and RDF Query Language</em> 的首字母缩略词，发音为 “sparkle”。）<br>它早于 Cypher，由于 Cypher 的模式匹配是从 SPARQL 借用的，它们看起来非常相似。<br>SPARQL 得到 Amazon Neptune、AllegroGraph、Blazegraph、OpenLink Virtuoso、Apache Jena 和各种其他三元组存储的支持</p>
<h4 id="Datalog：递归关系查询"><a href="#Datalog：递归关系查询" class="headerlink" title="Datalog：递归关系查询"></a>Datalog：递归关系查询</h4><p>Datalog 是一种比 SPARQL 或 Cypher 更古老的语言：它源于 20 世纪 80 年代的学术研究<br>它是一种非常有表现力的语言，对于复杂查询特别强大。几个小众数据库，包括 Datomic、LogicBlox、CozoDB 和 LinkedIn 的 LIquid使用 Datalog 作为它们的查询语言。<br>Datalog 实际上基于关系数据模型，递归查询是 Datalog 的特殊优势。<br>Datalog 数据库的内容由 <em>事实</em> 组成，每个事实对应于关系表中的一行。<br>Datalog 是 Prolog 的子集，这是一种编程语言，如果你学过计算机科学，你可能见过它。</p>
<h4 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h4><p>GraphQL 是一种查询语言，从设计上讲，它比我们在本章中看到的其他查询语言限制性更强。<br>目的是允许在用户设备上运行的客户端软件（如移动应用程序或 JavaScript Web 应用程序前端）请求具有特定结构的 JSON 文档，其中包含渲染其用户界面所需的字段。GraphQL 接口允许开发人员快速更改客户端代码中的查询，而无需更改服务器端 API。<br>采用 GraphQL 的组织通常需要工具将 GraphQL 查询转换为对内部服务的请求，这些服务通常使用 REST 或 gRPC<br>GraphQL 不允许递归查询（与 Cypher、SPARQL、SQL 或 Datalog 不同），并且不允许任意搜索条件</p>
<h3 id="事件溯源与-CQRS"><a href="#事件溯源与-CQRS" class="headerlink" title="事件溯源与 CQRS"></a>事件溯源与 CQRS</h3><p>迄今为止讨论的所有数据模型中，数据以与写入相同的形式被查询 —— 无论是 JSON 文档、表中的行，还是图中的顶点和边。<br>使用事件作为真相源，并将每个状态变化表达为事件的想法被称为 **<em>事件溯源</em>**。<br>维护单独的读优化表示并从写优化表示派生它们的原则称为 <strong>_命令查询责任分离</strong>（CQRS）_<br>事件溯源与星型模式事实表之间的相似之处：事件溯源与星型模式事实表之间的相似之处</p>
<ul>
<li>事实表中的行都具有相同的列集</li>
<li>事件溯源中可能有许多不同的事件类型，每种都有不同的属性。事实表是无序集合<br>事件溯源和 CQRS 有几个优点：</li>
<li>事件更好地传达了 <em>为什么</em> 发生某事的意图</li>
<li>事件溯源的关键原则是物化视图以可重现的方式从事件日志派生</li>
<li>可以有多个物化视图，针对应用程序所需的特定查询进行优化。</li>
<li>以新方式呈现现有信息，很容易从现有事件日志构建新的物化视图。<br>事件溯源和 CQRS 也有缺点：</li>
<li>如果涉及外部信息，可能会得到不同的结果</li>
<li>事件不可变的要求会在事件包含用户的个人数据时产生问题，因为用户可能行使他们的权利（例如，根据 GDPR）请求删除他们的数据</li>
<li>如果存在外部可见的副作用，重新处理事件需要小心<br>有一些专业系统：EventStoreDB、MartenDB（基于 PostgreSQL）和 Axon Framework，还可以使用消息代理（如 Apache Kafka）来存储事件日志<br>唯一重要的要求是事件存储系统必须保证所有物化视图以与它们在日志中出现的完全相同的顺序处理事件</li>
</ul>
<h3 id="数据框、矩阵与数组"><a href="#数据框、矩阵与数组" class="headerlink" title="数据框、矩阵与数组"></a>数据框、矩阵与数组</h3><p>数据框：R 语言、Python 的 Pandas 库、Apache Spark、ArcticDB、Dask 和其他系统支持的数据模型。它们是数据科学家为训练机器学习模型准备数据的流行工具，但它们也广泛用于数据探索、统计数据分析、数据可视化和类似目的。<br>数据框通常不是通过声明式查询（如 SQL）而是通过一系列修改其结构和内容的命令来操作的。<br>[[Pasted image 20250813161537.png]]<br>矩阵只能包含数字，各种技术用于将非数字数据转换为矩阵中的数字。例如：日期缩放、独热编码<br>数据以数字矩阵的形式存在，它就适合线性代数运算。<br>数据框足够灵活，允许数据从关系形式逐渐演变为矩阵表示，同时让数据科学家控制最适合实现数据分析或模型训练过程目标的表示。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><em>关系模型</em> 尽管已有半个多世纪的历史，但对许多应用来说仍然是一个重要的数据模型——特别是在数据仓库和商业分析中，关系星型或雪花模式和 SQL 查询无处不在。然而，关系数据的几种替代方案也在其他领域变得流行：</p>
<ul>
<li><em>文档模型</em> 针对数据以独立的 JSON 文档形式出现的用例，以及一个文档与另一个文档之间的关系很少的情况。</li>
<li><em>图数据模型</em> 走向相反的方向，针对任何东西都可能与一切相关的用例，以及查询可能需要遍历多个跳跃才能找到感兴趣的数据（可以使用 Cypher、SPARQL 或 Datalog 中的递归查询来表达）。</li>
<li><em>数据框</em> 将关系数据推广到大量列，从而在数据库和构成大量机器学习、统计数据分析和科学计算基础的多维数组之间提供桥梁。</li>
</ul>
<h2 id="4-存储与检索"><a href="#4-存储与检索" class="headerlink" title="4. 存储与检索"></a>4. 存储与检索</h2><p>数据库如何存储你提供的数据，以及当你请求时如何再次找到这些数据。<br>事务型工作负载（OLTP）优化的存储引擎和针对分析型工作负载优化的存储引擎之间存在巨大差异</p>
<h2 id="OLTP-系统的存储与索引"><a href="#OLTP-系统的存储与索引" class="headerlink" title="OLTP 系统的存储与索引"></a>OLTP 系统的存储与索引</h2><p>世界上最简单的数据库</p>
<pre><code class="bash">#/bin/bash
db_set () &#123;
  echo &quot;$1,$2&quot; &gt;&gt; database
&#125;
db_get () &#123;
  grep &quot;^$1,&quot; database | sed -e &quot;s/^$1,//&quot; | tail -n 1
&#125;```
这两个函数实现了一个键值存储。你可以调用 `db_set key value`，它将在数据库中存储 `key` 和 `value`。
为了高效地找到数据库中特定键的值，我们需要一个不同的数据结构：_索引_。
索引是从主数据派生出的 _额外_ 结构。许多数据库允许你添加和删除索引，这不会影响数据库的内容；它只影响查询的性能。
维护额外的结构会产生开销，特别是在写入时。对于写入，很难超越简单地追加到文件的性能，因为这是最简单的写入操作。**任何类型的索引通常都会减慢写入速度**，因为每次写入数据时也需要更新索引。
数据库通常不会默认为所有内容建立索引，而是要求你 —— 编写应用程序或管理数据库的人 —— 使用你对应用程序典型查询模式的了解来手动选择索引。
#### 日志结构存储
继续将数据存储在 `db_set` 写入的仅追加文件中，你只是想加快读取速度。一种方法是在内存中保留一个哈希映射，其中每个键都映射到文件中可以找到该键最新值的字节偏移量
[[Pasted image 20250815105925.png]]
向文件追加新的键值对时，你也会更新哈希映射以反映刚刚写入数据的偏移量。
存在几个问题：
- 永远不会释放被覆盖的旧日志条目占用的磁盘空间；如果你不断写入数据库，可能会耗尽磁盘空间。
- 哈希映射不是持久化的，所以当你重启数据库时必须重建它
- 哈希表必须适合内存。原则上，你可以在磁盘上维护哈希表，但不幸的是，很难让磁盘上的哈希映射表现良好。
- 范围查询效率不高。
##### SSTable 文件格式
实际上，哈希表很少用于数据库索引，相反，保持数据 _按键排序_ 的结构更为常见
这种结构的一个例子是 _排序字符串表_（_Sorted String Table_），简称 _SSTable_，这种文件格式也存储键值对，但它确保它们按键排序，每个键在文件中只出现一次。
[[Pasted image 20250815143608.png]]
将 SSTable 中的键值对分组为几千字节的 _块_，然后在索引中存储每个块的第一个键。这种只存储部分键的索引称为 _稀疏_ 索引。这个索引存储在 SSTable 的单独部分，例如使用不可变 B 树、字典树或其他允许查询快速查找特定键的数据结构。
一个块的第一个键是 `handbag`，下一个块的第一个键是 `handsome`。现在假设你要查找键 `handiwork`，它没有出现在稀疏索引中。由于排序，你知道 `handiwork` 必须出现在 `handbag` 和 `handsome` 之间。这意味着你可以寻找到 `handbag` 的偏移量，然后从那里扫描文件，直到找到 `handiwork`
每个记录块都可以压缩，除了节省磁盘空间外，压缩还减少了 I/O 带宽使用，代价是使用更多一点的 CPU 时间。
##### 构建和合并 SSTable
SSTable 文件格式在读取方面比仅追加日志更好，但它使写入更加困难。
每次在中间某处插入键时都必须重写整个 SSTable，写入将变得太昂贵。
可以用 _日志结构_ 方法解决这个问题，这是仅追加日志和排序文件之间的混合：
1. 当写入操作到来时，将其添加到内存中的有序映射数据结构中，例如红黑树、跳表 或字典树。使用这些数据结构，你可以按任意顺序插入键，高效地查找它们，并按排序顺序读回它们。这个内存数据结构称为 _内存表_（_memtable_）。
2. 当内存表变得大于某个阈值（通常是几兆字节）时，将其按排序顺序作为 SSTable 文件写入磁盘。我们将这个新的 SSTable 文件称为数据库的最新 _段_，它与旧段一起作为单独的文件存储。每个段都有自己内容的单独索引。当新段被写入磁盘时，数据库可以继续写入新的内存表实例，当 SSTable 写入完成时，旧内存表的内存被释放。
3. 为了读取某个键的值，首先尝试在内存表和最新的磁盘段中找到该键。如果没有找到，就在下一个较旧的段中查找，依此类推，直到找到键或到达最旧的段。如果键没有出现在任何段中，则它不存在于数据库中。
4. 不地在后台运行合并和压实过程，以合并段文件并丢弃被覆盖或删除的值。
合并段的工作方式类似于 _归并排序_ 算法：
并排开始读取输入文件，查看每个文件中的第一个键，将最低的键（根据排序顺序）复制到输出文件，然后重复。如果同一个键出现在多个输入文件中，只保留较新的值。这会产生一个新的合并段文件，也按键排序，每个键只有一个值，并且它使用最少的内存，因为我们可以一次遍历一个键的 SSTable。
[[Pasted image 20250815150221.png]]
为了确保数据库崩溃时内存表中的数据不会丢失，存储引擎在磁盘上保留一个单独的日志，每次写入都会立即追加到该日志中。此日志不按键排序，但这无关紧要，因为它的唯一目的是在崩溃后恢复内存表。每次内存表被写出到 SSTable 后，日志的相应部分就可以丢弃。
如果你想删除一个键及其关联的值，你必须向数据文件追加一个称为 _墓碑_（_tombstone_）的特殊删除记录。当日志段合并时，墓碑告诉合并过程丢弃已删除键的任何先前值。一旦墓碑合并到最旧的段中，它就可以被丢弃。
这里描述的算法本质上就是 **RocksDB、Cassandra、Scylla 和 HBase** 中使用的算法，它们都受到 Google 的 Bigtable 论文 9 的启发
1996 年以 _日志结构合并树_（_Log-Structured Merge-Tree_）或 _LSM 树_（_LSM-Tree_）的名称发布，建立在早期日志结构文件系统工作的基础上 。因此，基于合并和压实排序文件原理的存储引擎通常被称为 _LSM 存储引擎_。
在 LSM 存储引擎中，**段文件是一次性写入**的（通过写出内存表或合并一些现有段），此后它是不可变的。段的合并和压实可以在后台线程中完成，当它进行时，我们**仍然可以使用旧的段文件继续提供读取服务**。当合并过程完成时，我们将读取请求切换到使用新的合并段而不是旧段，然后可以删除旧的段文件。
段文件也非常适合写入对象存储。
如果在写出内存表或合并段时发生崩溃，数据库可以删除未完成的 SSTable 并重新开始。
##### 布隆过滤器
使用 LSM 存储，**读取很久以前更新的键或不存在的键可能会很慢**，因为存储引擎需要检查多个段文件。为了加快此类读取，LSM 存储引擎通常在每个段中包含一个 _布隆过滤器_（_Bloom filter_），它提供了一种快速但近似的方法来检查特定键是否出现在特定 SSTable 中。
一个包含两个键和 16 位的布隆过滤器示例：
[[Pasted image 20250815152322.png]]对于 SSTable 中的每个键，我们计算一个哈希函数，产生一组数字，然后将其解释为位数组的索引
将对应于这些索引的位设置为 1，其余保持为 0。例如，键 `handbag` 哈希为数字 (2, 9, 4)，所以我们将第 2、9 和 4 位设置为 1。然后将**位图与键的稀疏索引**一起存储为 SSTable 的一部分。这需要一点额外的空间，但与 SSTable 的其余部分相比，布隆过滤器通常很小。
- **查询不在**：如果至少有一个位是 0，我们知道该键肯定不在 SSTable 中。
- **查询可能在**：如果查询中的位都是 1，那么该键很可能在 SSTable 中，但也有可能是巧合，所有这些位都被其他键设置为 1。这种看起来键存在但实际上不存在的情况称为 **_假阳性_**（_false positive_）。
假阳性的概率取决于键的数量、每个键设置的位数和布隆过滤器中的总位数。
经验法则：为 SSTable 中的每个键分配 10 位布隆过滤器空间以获得 1% 的假阳性概率，每为每个键分配额外的 5 位，概率就会降低十倍。
##### 压实策略
SM 存储如何选择何时执行压实，以及在压实中包括哪些 SSTable。许多基于 LSM 的存储系统允许你配置使用哪种压实策略，常见选择如下：
- **分层压实**：较新和较小的 SSTable 依次合并到较旧和较大的 SSTable 中，可以处理非常高的写入吞吐量
- **分级压实**：键范围被分成较小的 SSTable，较旧的数据被移动到单独的&quot;级别&quot;中，这允许压实更增量地进行，并且比分层策略使用更少的磁盘空间。这种策略对于读取比分层压实更有效，因为存储引擎需要读取更少的 SSTable 来检查它们是否包含该键。
**经验法则**：如果你主要有写入而读取很少，分层压实表现更好，而如果你的工作负载以读取为主，分级压实表现更好。
**嵌入式存储引擎**的例子包括 RocksDB、SQLite、LMDB、DuckDB 和 KùzuDB。在与应用程序代码相同的进程中运行的库，通常读取和写入本地磁盘上的文件，你通过正常的函数调用与它们交互。
#### B 树
按键读取和写入数据库记录最广泛使用的结构是 _B 树_。
1970 年引入B树，几乎所有关系数据库中的标准索引实现，许多非关系数据库也使用它们。
像 SSTable 一样，B 树按键保持键值对排序，这允许高效的键值查找和范围查询
**B 树有着非常不同的设计理念。**
- LSM：将数据库分解为可变大小的 _段_，通常为几兆字节或更大，写入一次后就不可变。
- B树：将数据库分解为固定大小的 _块_ 或 _页_，并可能就地覆盖页。页传统上大小为 4 KiB，但 PostgreSQL 现在默认使用 8 KiB，MySQL 默认使用 16 KiB。
每个页都可以使用页号来标识，这允许一个页引用另一个页 —— 类似于指针，但在磁盘上而不是在内存中。如果所有页都存储在同一个文件中，将页号乘以页大小就给我们文件中页所在位置的字节偏移量。我们可以使用这些页引用来构建页树
[[Pasted image 20250815154238.png]]一个页被指定为 B 树的 _根_；每当你想在索引中查找一个键时，你就从这里开始。该页包含几个键和对子页的引用。每个子负责一个连续的键范围，引用之间的键指示这些范围之间的边界在哪里。
B 树的一个页中对子页的引用数称为 _分支因子_。分支因子取决于存储页引用和范围边界所需的空间量，但通常为几百。
更新 B 树中现有键的值，你搜索包含该键的叶页，并用包含新值的版本覆盖磁盘上的该页。如果你想添加一个新键，你需要找到其范围包含新键的页并将其添加到该页。如果页中没有足够的空闲空间来容纳新键，则页被分成两个半满的页，并更新父页以说明键范围的新细分。
[[Pasted image 20250815154759.png]]想插入键 334，但范围 333–345 的页已经满了。因此，我们将其分成范围 333–337（包括新键）的页和 337–344 的页。我们还必须更新父页以引用两个子页，它们之间的边界值为 337。如果父页没有足够的空间容纳新引用，它也可能需要被分割，分割可以一直持续到树的根。当根被分割时，我们在它上面创建一个新根。
这个算法确保树保持 _平衡_：具有 _n_ 个键的 B 树始终具有 _O_(log _n_) 的深度。大多数数据库可以适合三或四层深的 B 树，所以你不需要跟随许多页引用来找到你要查找的页。
##### 使 B 树可靠
B 树的基本底层写操作是用新数据覆盖磁盘上的页。
一次覆盖多个页，如在页分割中，是一个危险的操作：如果数据库在只写入了部分页后崩溃，你最终会得到一个损坏的树（例如，可能有一个 _孤立_ 页，它不是任何父页的子页）。如果硬件不能原子地写入整个页，你也可能最终得到部分写入的页（这称为 _撕裂页_（_torn page_））。
为了使数据库对崩溃具有弹性，B 树实现通常包括磁盘上的额外数据结构：**_预写日志_**（_write-ahead log_，WAL）。这是一个仅追加文件，每个 B 树修改必须在应用于树本身的页之前写入其中。当数据库在崩溃后恢复时，此日志用于将 B 树恢复到一致状态
为了提高性能，B 树实现通常不会立即将每个修改的页写入磁盘，而是**首先将 B 树页缓冲在内存**中一段时间。预写日志还确保在崩溃的情况下数据不会丢失：**只要数据已写入 WAL，并使用 `fsync()` 系统调用刷新到磁盘，数据就是持久的**，因为数据库将能够在崩溃后恢复它
##### B 树变体
- 一些数据库（如 LMDB）使用写时复制方案，而不是覆盖页并维护 WAL 以进行崩溃恢复。
- 通过不存储整个键而是缩写它来节省页中的空间。特别是在树内部的页中，键只需要提供足够的信息来充当键范围之间的边界。
- 为了加快按排序顺序扫描键范围，一些 B 树实现尝试布局树，使叶页按顺序出现在磁盘上，减少磁盘寻道次数。
#### 比较 B 树与 LSM 树
**经验法则**：LSM 树更适合写入密集型应用，而 B 树对读取更快。
存储引擎有时会混合两种方法的特征，例如具有多个 B 树并以 LSM 风格合并它们。
##### 读取性能
- B树：在 B 树中，查找键涉及在 B 树的每个级别读取一个页。由于级别数通常很小，这意味着从 B 树读取通常很快并且具有可预测的性能。
- LSM：在 LSM 存储引擎中，读取通常必须检查处于不同压实阶段的几个不同 SSTable，但布隆过滤器有助于减少所需的实际磁盘 I/O 操作数。
在 LSM 存储引擎中，读取通常必须检查处于不同压实阶段的几个不同 SSTable，但布隆过滤器有助于减少所需的实际磁盘 I/O 操作数。使得**范围查询在 LSM 方法中比点查询更昂贵**
现代 SSD（特别是 NVMe）可以并行执行许多独立的读请求。LSM 树和 B 树都能够提供高读取吞吐量，但存储引擎需要仔细设计以利用这种并行性
##### 顺序与随机写入
- B树：如果应用程序写入的键分散在整个键空间中，生成的磁盘操作也会随机分散，因为存储引擎需要覆盖的页可能位于磁盘的任何位置。
- LSM：日志结构存储引擎一次写入整个段文件（无论是写出内存表还是压实现有段），这比 B 树中的页大得多。
许多小的、分散的写入模式（如 B 树中的）称为 **_随机写入_**，而较少的大写入模式（如 LSM 树中的）称为 **_顺序写入_**。磁盘通常具有比随机写入更高的顺序写入吞吐量，这意味着**日志结构存储引擎通常可以在相同硬件上处理比 B 树更高的写入吞吐量**。这种差异在旋转磁盘硬盘（HDD）上特别大；在今天大多数数据库使用的固态硬盘（SSD）上，差异较小，但仍然明显
- 旋转磁盘硬盘（HDD）上，**顺序写入比随机写入快得多**：随机写入必须机械地将磁头移动到新位置，并等待盘片的正确部分经过磁头下方，这需要几毫秒 —— 在计算时间尺度上是永恒的。
- SSD（固态硬盘）包括 NVMe（非易失性内存快速，即连接到 PCI Express 总线的闪存）现在已经在许多用例中超越了 HDD，它们不受这种机械限制。SSD 对**顺序写入的吞吐量也高于随机写入**。原因是闪存可以一次读取或写入一页（通常为 4 KiB），但**只能一次擦除一个块**。块中的某些页可能包含有效数据，而其他页可能包含不再需要的数据。在擦除块之前，控制器必须首先将包含有效数据的页移动到其他块中；这个过程称为 **_垃圾回收_**（GC）
##### 写放大
对于任何类型的存储引擎，来自应用程序的一次写请求都会转换为底层磁盘上的多个 I/O 操作。
- 对于 LSM 树，一个值首先被写入日志以保证持久性，然后在内存表写入磁盘时再次写入，并且每次键值对参与压实时再次写入。
- B 树索引必须至少写入每条数据两次：一次写入预写日志，一次写入树页本身。此外，它们有时需要写出整个页，即使该页中只有几个字节发生了变化，以确保 B 树在崩溃或断电后可以正确恢复
如果你获取在某个工作负载中写入磁盘的总字节数，然后除以如果你只是写入没有索引的仅追加日志需要写入的字节数，你就得到了 **_写放大_**。
写放大是 LSM 树和 B 树中的问题。哪个更好取决于各种因素，例如键和值的长度，以及你覆盖现有键与插入新键的频率
LSM 树往往具有较低的写放大，因为它们不必写入整个页，并且可以压缩 SSTable 的块
##### 磁盘空间使用
**_主键_ 索引**：主键唯一标识关系表中的一行，或文档数据库中的一个文档，或图数据库中的一个顶点。数据库中的其他记录可以通过其主键（或 ID）引用该行/文档/顶点，索引用于解析此类引用。
**_二级索引_**：可以使用 `CREATE INDEX` 命令在同一个表上创建多个二级索引，允许你按主键以外的列进行搜索。在二级索引中，索引值不一定是唯一的；也就是说，同一索引条目下可能有许多行（文档、顶点）。这可以通过两种方式解决：要么使索引中的每个值成为匹配行标识符的列表（如全文索引中的倒排列表），要么通过向其追加行标识符使每个条目唯一。具有就地更新的存储引擎（如 B 树）和日志结构存储都可用于实现索引。
##### 在索引中存储值
索引中的键是查询搜索的内容，但值可以是几种东西之一：
- 如果实际数据（行、文档、顶点）直接存储在索引结构中，则称为 _聚簇索引_。例如，在 MySQL 的 InnoDB 存储引擎中，表的主键始终是聚簇索引
- 值可以是对实际数据的引用：要么是相关行的主键（InnoDB 对二级索引这样做），要么是对磁盘上位置的直接引用。在后一种情况下，存储行的地方称为 _堆文件_，它以无特定顺序存储数据（它可能是仅追加的，或者它可能跟踪已删除的行以便稍后用新数据覆盖它们）。例如，Postgres 使用堆文件方法
- 两者之间的折中是 _覆盖索引_ 或 _包含列的索引_，它在索引中存储表的 _某些_ 列，除了在堆上或主键聚簇索引中存储完整行
#### 全内存存储
随着 RAM 变得更便宜，每千兆字节成本的论点被侵蚀。许多数据集根本不是那么大，因此将它们完全保留在内存中是完全可行的，可能分布在几台机器上。这导致了 _内存数据库_ 的发展。
一些内存键值存储，例如 Memcached，仅用于缓存，如果机器重新启动，数据丢失是可以接受的。但其他内存数据库旨在实现持久性，这可以通过特殊硬件（例如电池供电的 RAM）、将更改日志写入磁盘、将定期快照写入磁盘或将内存状态复制到其他机器来实现。
VoltDB、SingleStore 和 Oracle TimesTen 等产品是具有关系模型的内存数据库
Redis 和 Couchbase 通过异步写入磁盘提供弱持久性。
内存数据库的另一个有趣领域是提供难以使用基于磁盘的索引实现的数据模型。例如，Redis 为各种数据结构（例如优先队列和集合）提供类似数据库的接口。因为它将所有数据保留在内存中，其实现相对简单。
### 分析型数据存储
表面上，数据仓库和关系型 OLTP 数据库看起来很相似，因为它们都有 SQL 查询接口。然而，系统的内部可能看起来完全不同，因为它们针对非常不同的查询模式进行了优化。许多数据库供应商现在专注于支持事务处理或分析工作负载，但不是两者兼而有之。
一些数据库，如 Microsoft SQL Server、SAP HANA 和 SingleStore，在同一产品中支持事务处理和数据仓库。
#### 云数据仓库
与传统数据仓库不同，云数据仓库利用可扩展的云基础设施，如对象存储和无服务器计算平台。
Apache Hive、Trino 和 Apache Spark 等开源数据仓库也随着云的发展而发展。随着分析数据存储转移到对象存储上的数据湖，开源仓库已经开始分解：
- **查询引擎**：Trino、Apache DataFusion 和 Presto 等查询引擎解析 SQL 查询，将其优化为执行计划，并针对数据执行它们。执行通常需要并行、分布式数据处理任务。一些查询引擎提供内置任务执行，而其他选择使用第三方执行框架，如 Apache Spark 或 Apache Flink。
- **存储格式**：存储格式确定表的行如何编码为文件中的字节，然后通常存储在对象存储或分布式文件系统中。此类存储格式的示例包括 Parquet、ORC、Lance 或 Nimble
- **表格式**：以 Apache Parquet 和类似存储格式编写的文件一旦编写通常是不可变的。为了支持行插入和删除，使用 Apache Iceberg 或 Databricks 的 Delta 格式等表格式。表格式指定定义哪些文件构成表以及表模式的文件格式。此类格式还提供高级功能，例如时间旅行（查询表在以前时间点的能力）、垃圾回收，甚至事务。
- **数据目录**：就像表格式定义哪些文件构成表一样，数据目录定义哪些表组成数据库。目录用于创建、重命名和删除表。与存储和表格式不同，Snowflake 的 Polaris 和 Databricks 的 Unity Catalog 等数据目录通常作为可以使用 REST 接口查询的独立服务运行。Apache Iceberg 也提供目录，可以在客户端内运行或作为单独的进程运行。
#### 列式存储
数据仓库按照惯例通常使用带有大型事实表的关系模式，该表包含对维度表的外键引用。
在本节中我们将重点关注事实的存储。
典型的数据仓库查询一次只访问其中的 4 或 5 列。
大多数 OLTP 数据库中，存储是以 _面向行_ 的方式布局的：表中一行的所有值彼此相邻存储。文档数据库类似：整个文档通常作为一个连续的字节序列存储。
_面向列_（或 _列式_）存储背后的想法很简单：不要将一行中的所有值存储在一起，而是将每 _列_ 中的所有值存储在一起。如果每列单独存储，查询只需要读取和解析该查询中使用的那些列，这可以节省大量工作。
[[Pasted image 20250815191357.png]]
列式存储引擎并不真的一次存储整个列（可能包含数万亿行）。相反，它们将表分解为数千或数百万行的块，并且在每个块内，它们分别存储每列的值
由于许多查询都限制在特定的日期范围内，因此通常使每个块包含特定时间戳范围的行。然后查询只需要在与所需日期范围重叠的那些块中加载它需要的列。
列式存储如今几乎用于所有分析数据库，从大规模云数据仓库（如 Snowflake ）到单节点嵌入式数据库（如 DuckDB ），以及产品分析系统（如 Pinot 和 Druid ）。它用于存储格式，如 Parquet、ORC 、Lance 和 Nimble，以及内存分析格式，如 Apache Arrow   和 Pandas/NumPy。一些时间序列数据库，如 InfluxDB IOx 和 TimescaleDB，也基于面向列的存储。
##### 列压缩
在数据仓库中特别有效的一种技术是 _位图编码_，可以将具有 _n_ 个不同值的列转换为 _n_ 个单独的位图：每个不同值一个位图，每行一位。如果该行具有该值，则该位为 1，否则为 0。
[[file-20250816215228398.png]]
位图索引非常适合数据仓库中常见的查询类型，位图也可用于回答图查询
不要将**面向列的数据库**与 **_宽列_（也称为 _列族_）**数据模型**混淆，在该模型中，一行可以有数千列，并且不需要所有行都有相同的列。
尽管名称相似，宽列数据库是面向行的，因为它们将一行中的所有值存储在一起。Google 的 Bigtable、Apache Accumulo 和 HBase 是宽列模型的例子。
##### 列存储中的排序顺序
在列存储中，行的存储顺序并不一定重要。最简单的是按插入顺序存储它们，因为这样插入新行只需追加到每列。独立排序每列是没有意义的
数据库管理员可以使用他们对常见查询的了解来选择表应按哪些列排序。
##### 写入列式存储
使用列式存储，在排序表的中间某处写入单个行将非常低效，因为你必须从插入位置开始重写所有压缩列。但是，一次批量写入许多行会分摊重写这些列的成本，使其高效。
通常使用日志结构方法以批次执行写入。所有写入首先进入面向行的、排序的内存存储。当积累了足够的写入时，它们将与磁盘上的列编码文件合并，并批量写入新文件。由于旧文件保持不可变，新文件一次写入，对象存储非常适合存储这些文件。
#### 查询执行：编译与向量化
用于分析的复杂 SQL 查询被分解为由多个阶段组成的 _查询计划_，称为 _算子_，这些算子可能分布在多台机器上以并行执行。
查询规划器可以通过选择使用哪些算子、以何种顺序执行它们以及在哪里运行每个算子来执行大量优化。
高效查询执行的两种替代方法已经出现：
- **查询编译**：查询引擎获取 SQL 查询并生成用于执行它的代码。代码逐行迭代，查看感兴趣列中的值，执行所需的任何比较或计算，如果满足所需条件，则将必要的值复制到输出缓冲区。查询引擎将生成的代码编译为机器代码（通常使用现有编译器，如 LLVM），然后在已加载到内存中的列编码数据上运行它。
- **向量化处理**：查询被解释，而不是编译，但通过批量处理列中的许多值而不是逐行迭代来提高速度。一组固定的预定义算子内置在数据库中；我们可以向它们传递参数并获得一批结果
两个位图之间的按位 AND 适合向量化。可以将 `product_sk` 列和&quot;香蕉&quot;的 ID 传递给相等算子，并获得一个位图（输入列中每个值一位，如果是香蕉则为 1）；然后我们可以将 `store_sk` 列和感兴趣商店的 ID 传递给相同的相等算子，并获得另一个位图；然后我们可以将两个位图传递给&quot;按位 AND&quot;算子，结果将是一个位图，包含特定商店中所有香蕉销售的 1。
[[file-20250816220235402.png]]
两者都可以通过利用现代 CPU 的特性来实现非常好的性能：
- 优先选择顺序内存访问而不是随机访问以减少缓存未命中
- 在紧密的内部循环中完成大部分工作（即，具有少量指令且没有函数调用）以保持 CPU 指令处理管道繁忙并避免分支预测错误
- 利用并行性，例如多线程和单指令多数据（SIMD）指令
- 直接对压缩数据进行操作，而无需将其解码为单独的内存表示
#### 物化视图与多维数据集
 **_物化视图_**：在关系数据模型中，它们是表状对象，其内容是某些查询的结果。**物化视图是查询结果的实际副本**，写入磁盘，而虚拟视图只是编写查询的快捷方式。当你从虚拟视图读取时，SQL 引擎会即时将其扩展为视图的基础查询，然后处理扩展的查询。
物化视图可以改善在重复需要执行相同查询的工作负载中的读取性能。
**_物化聚合_** 是一种可以在数据仓库中有用的物化视图类型。
_多维数据集_ 或 _OLAP 立方体_ 通过创建按不同维度分组的聚合网格来缓存查询最常使用的一些计数或总和。
[[file-20250816220810602.png]]
现在假设每个事实只有两个维度表的外键 —— 在图 中，这些是 `date_key` 和 `product_sk`。你现在可以绘制一个二维表，日期沿着一个轴，产品沿着另一个轴。每个单元格包含具有该日期-产品组合的所有事实的属性（例如 `net_price`）的聚合（例如 `SUM`）。然后，你可以沿着每行或列应用相同的聚合，并获得已减少一个维度的摘要（不管日期的产品销售，或不管产品的日期销售）。
物化多维数据集的优点是某些查询变得非常快，因为它们已经有效地预先计算了。例如，如果你想知道昨天每个商店的总销售额，你只需要查看适当维度的总计 —— 不需要扫描数百万行。
缺点是多维数据集没有与查询原始数据相同的灵活性。
大多数数据仓库尽可能多地保留原始数据，并仅将聚合（如多维数据集）用作某些查询的性能提升。
### 多维索引与全文索引
最常见的多列索引类型称为 **_联合索引_**，它通过将一列追加到另一列来将几个字段组合成一个键（索引定义指定字段以何种顺序连接）。**_多维索引_** 允许你一次查询多个列。在地理空间数据中这尤其重要。
#### 全文检索
**全文检索**：允许你通过可能出现在文本中任何位置的关键字搜索文本文档集合（网页、产品描述等）
可以将全文检索视为另一种多维查询：在这种情况下，可能出现在文本中的每个单词（_词项_）是一个维度。包含词项 _x_ 的文档在维度 _x_ 中的值为 1，不包含 _x_ 的文档的值为 0。
许多搜索引擎用来回答此类查询的数据结构称为 _倒排索引_。这是一个键值结构，其中键是词项，值是包含该词项的所有文档的 ID 列表（_倒排列表_）。如果文档 ID 是顺序数字，倒排列表也可以表示为稀疏位图。
Elasticsearch 和 Solr 使用的全文索引引擎 Lucene 就是这样工作的。它将词项到倒排列表的映射存储在类似 SSTable 的排序文件中，这些文件使用我们在本章前面看到的相同日志结构方法在后台合并
除了将文本分解为单词，另一种选择是查找长度为 _n_ 的所有子字符串，称为 _n_ 元语法。例如，字符串 `&quot;hello&quot;` 的三元语法（_n_ = 3）是 `&quot;hel&quot;`、`&quot;ell&quot;` 和 `&quot;llo&quot;`
为了处理文档或查询中的拼写错误，Lucene 能够在一定编辑距离内搜索文本中的单词（编辑距离为 1 意味着已添加、删除或替换了一个字母）.它通过将词项集存储为字符上的有限状态自动机（类似于 _字典树_ )并将其转换为 _莱文斯坦自动机_ 来实现，该自动机支持在给定编辑距离内高效搜索单词。
#### 向量嵌入
为了理解文档的语义 —— 它的含义 —— 语义搜索索引使用嵌入模型将文档转换为浮点值向量，称为 **_向量嵌入_**。向量表示多维空间中的一个点，每个浮点值表示文档沿着一个维度轴的位置。嵌入模型生成的向量嵌入在（这个多维空间中）彼此接近，当嵌入的输入文档在语义上相似时。
索引擎使用距离函数（如余弦相似度或欧几里得距离）来测量向量之间的距离。余弦相似度测量两个向量角度的余弦以确定它们的接近程度，而欧几里得距离测量空间中两点之间的直线距离。
许多早期的嵌入模型，如 Word2Vec、BERT 和 GPT 都处理文本数据。这些模型通常实现为神经网络。研究人员继续为视频、音频和图像创建嵌入模型。最近，模型架构已经变成 _多模态_ 的：单个模型可以为多种模态（如文本和图像）生成向量嵌入。
语义搜索引擎在用户输入查询时使用嵌入模型生成向量嵌入。用户的查询和相关上下文（例如用户的位置）被输入到嵌入模型中。嵌入模型生成查询的向量嵌入后，搜索引擎必须使用向量索引找到具有相似向量嵌入的文档。
向量索引存储文档集合的向量嵌入。要查询索引，你传入查询的向量嵌入，索引返回其向量最接近查询向量的文档。使用专门的向量索引，例如：
- **平面索引**：向量按原样存储在索引中。查询必须读取每个向量并测量其与查询向量的距离。平面索引是准确的，但测量查询与每个向量之间的距离很慢。
- **倒排文件（IVF）索引**：向量空间被聚类为向量的分区（称为 _质心_），以减少必须比较的向量数量。IVF 索引比平面索引更快，但只能给出近似结果：即使查询和文档彼此接近，它们也可能落入不同的分区。
- **分层可导航小世界**：HNSW 索引维护向量空间的多个层，每一层都表示为一个图，其中节点表示向量，边表示与附近向量的接近度。与 IVF 索引一样，HNSW 索引是近似的。
[[file-20250816223315450.png]]
## 5. 编码与演化
</code></pre>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/08/16/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/" rel="prev" title="深入剖析Kubernetes">
      <i class="fa fa-chevron-left"></i> 深入剖析Kubernetes
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/08/16/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/" rel="next" title="凤凰架构">
      凤凰架构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%8F%E8%A8%80"><span class="nav-number">2.</span> <span class="nav-text">序言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="nav-number">3.</span> <span class="nav-text">第一部分：数据系统基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="nav-number">3.1.</span> <span class="nav-text">1、数据系统架构中的权衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E5%9E%8B%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.1.1.</span> <span class="nav-text">分析型与事务型系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%86%E6%9E%90%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">事务处理与分析的特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">数据仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%88%B0%E6%95%B0%E6%8D%AE%E6%B9%96"><span class="nav-number">3.1.1.2.1.</span> <span class="nav-text">从数据仓库到数据湖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E8%B6%8A%E6%95%B0%E6%8D%AE%E6%B9%96"><span class="nav-number">3.1.1.2.2.</span> <span class="nav-text">超越数据湖</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E5%A8%81%E6%95%B0%E6%8D%AE%E6%BA%90%E4%B8%8E%E6%B4%BE%E7%94%9F%E6%95%B0%E6%8D%AE"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">权威数据源与派生数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E4%B8%8E%E8%87%AA%E6%89%98%E7%AE%A1"><span class="nav-number">3.1.2.</span> <span class="nav-text">云服务与自托管</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%A9%E5%BC%8A"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">云服务的利弊</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">云原生系统架构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%86%E5%B1%82"><span class="nav-number">3.1.2.2.0.1.</span> <span class="nav-text">云服务的分层</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E5%88%86%E7%A6%BB"><span class="nav-number">3.1.2.2.0.2.</span> <span class="nav-text">存储和计算的分离</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%91%E6%97%B6%E4%BB%A3%E7%9A%84%E8%BF%90%E7%BB%B4"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">云时代的运维</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%8D%95%E8%8A%82%E7%82%B9%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.1.3.</span> <span class="nav-text">分布式与单节点系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">分布式系统的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E-Serverless"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">微服务与 Serverless</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">云计算与超级计算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E3%80%81%E6%B3%95%E5%BE%8B%E4%B8%8E%E7%A4%BE%E4%BC%9A"><span class="nav-number">3.1.4.</span> <span class="nav-text">数据系统、法律与社会</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9A%E4%B9%89%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82"><span class="nav-number">3.2.</span> <span class="nav-text">2. 定义非功能性需求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%EF%BC%9A%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E9%A6%96%E9%A1%B5%E6%97%B6%E9%97%B4%E7%BA%BF"><span class="nav-number">3.2.1.</span> <span class="nav-text">案例研究：社交网络首页时间线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%BA%BF%E7%9A%84%E7%89%A9%E5%8C%96%E4%B8%8E%E6%9B%B4%E6%96%B0"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">时间线的物化与更新</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E6%80%A7%E8%83%BD"><span class="nav-number">3.2.2.</span> <span class="nav-text">描述性能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E4%B8%8E%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">延迟与响应时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E5%9D%87%E5%80%BC%E3%80%81%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%8E%E7%99%BE%E5%88%86%E4%BD%8D%E6%95%B0"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">平均值、中位数与百分位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%8C%87%E6%A0%87%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">响应时间指标的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%B8%8E%E5%AE%B9%E9%94%99"><span class="nav-number">3.2.3.</span> <span class="nav-text">可靠性与容错</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E9%94%99"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">容错</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E4%B8%8E%E8%BD%AF%E4%BB%B6%E6%95%85%E9%9A%9C"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">硬件与软件故障</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%86%97%E4%BD%99%E5%AE%B9%E5%BF%8D%E7%A1%AC%E4%BB%B6%E6%95%85%E9%9A%9C"><span class="nav-number">3.2.3.2.1.</span> <span class="nav-text">通过冗余容忍硬件故障</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E6%95%85%E9%9A%9C"><span class="nav-number">3.2.3.2.2.</span> <span class="nav-text">软件故障</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%BA%E7%B1%BB%E4%B8%8E%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">人类与可靠性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7"><span class="nav-number">3.2.4.</span> <span class="nav-text">可伸缩性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E8%B4%9F%E8%BD%BD"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">描述负载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E3%80%81%E5%85%B1%E4%BA%AB%E7%A3%81%E7%9B%98%E4%B8%8E%E6%97%A0%E5%85%B1%E4%BA%AB%E6%9E%B6%E6%9E%84"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">共享内存、共享磁盘与无共享架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%E5%8E%9F%E5%88%99"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">可伸缩性原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BF%90%E7%BB%B4%E6%80%A7"><span class="nav-number">3.2.5.</span> <span class="nav-text">可运维性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%BF%90%E7%BB%B4%E6%80%A7%EF%BC%9A%E8%AE%A9%E8%BF%90%E7%BB%B4%E6%9B%B4%E8%BD%BB%E6%9D%BE"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">可运维性：让运维更轻松</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%80%A7%EF%BC%9A%E7%AE%A1%E7%90%86%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">简单性：管理复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E6%BC%94%E5%8C%96%E6%80%A7%EF%BC%9A%E8%AE%A9%E5%8F%98%E5%8C%96%E6%9B%B4%E5%AE%B9%E6%98%93"><span class="nav-number">3.2.5.3.</span> <span class="nav-text">可演化性：让变化更容易</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="nav-number">3.3.</span> <span class="nav-text">3. 数据模型与查询语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.3.1.</span> <span class="nav-text">关系模型与文档模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">对象关系不匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84%EF%BC%88ORM%EF%BC%89"><span class="nav-number">3.3.1.1.1.</span> <span class="nav-text">对象关系映射（ORM）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E7%9A%84%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.3.1.1.2.</span> <span class="nav-text">用于一对多关系的文档数据模型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%84%E8%8C%83%E5%8C%96%E3%80%81%E5%8F%8D%E8%A7%84%E8%8C%83%E5%8C%96%E4%B8%8E%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">规范化、反规范化与连接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="nav-number">3.3.1.2.1.</span> <span class="nav-text">规范化的权衡</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6%E4%B8%AD%E7%9A%84%E5%8F%8D%E8%A7%84%E8%8C%83%E5%8C%96"><span class="nav-number">3.3.1.2.2.</span> <span class="nav-text">社交网络案例研究中的反规范化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%E4%B8%8E%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">多对一与多对多关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%9F%E5%9E%8B%E4%B8%8E%E9%9B%AA%E8%8A%B1%E5%9E%8B%EF%BC%9A%E5%88%86%E6%9E%90%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.1.4.</span> <span class="nav-text">星型与雪花型：分析模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.3.1.5.</span> <span class="nav-text">何时使用哪种模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%BC%8F%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="nav-number">3.3.1.5.1.</span> <span class="nav-text">文档模型中的模式灵活性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B1%80%E9%83%A8%E6%80%A7"><span class="nav-number">3.3.1.5.2.</span> <span class="nav-text">读写的数据局部性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="nav-number">3.3.1.5.3.</span> <span class="nav-text">文档的查询语言</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E5%92%8C%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%9E%8D%E5%90%88"><span class="nav-number">3.3.1.5.4.</span> <span class="nav-text">文档和关系数据库的融合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.3.2.</span> <span class="nav-text">图数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%9B%BE"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">属性图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cypher-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">Cypher 查询语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL-%E4%B8%AD%E7%9A%84%E5%9B%BE%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">SQL 中的图查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E7%BB%84%E5%AD%98%E5%82%A8%E4%B8%8E-SPARQL"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">三元组存储与 SPARQL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RDF-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.3.2.4.1.</span> <span class="nav-text">RDF 数据模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SPARQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="nav-number">3.3.2.4.2.</span> <span class="nav-text">SPARQL 查询语言</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Datalog%EF%BC%9A%E9%80%92%E5%BD%92%E5%85%B3%E7%B3%BB%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.3.2.5.</span> <span class="nav-text">Datalog：递归关系查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GraphQL"><span class="nav-number">3.3.2.6.</span> <span class="nav-text">GraphQL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%BA%AF%E6%BA%90%E4%B8%8E-CQRS"><span class="nav-number">3.3.3.</span> <span class="nav-text">事件溯源与 CQRS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A1%86%E3%80%81%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="nav-number">3.3.4.</span> <span class="nav-text">数据框、矩阵与数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.3.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2"><span class="nav-number">3.4.</span> <span class="nav-text">4. 存储与检索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OLTP-%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95"><span class="nav-number">3.5.</span> <span class="nav-text">OLTP 系统的存储与索引</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
